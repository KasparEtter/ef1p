/*
Author: Kaspar Etter (https://kasparetter.com/)
Work: Explained from First Principles (https://ef1p.com/)
License: CC BY 4.0 (https://creativecommons.org/licenses/by/4.0/)
*/

import { Fragment, ReactElement, ReactNode } from 'react';

import { getLastElement, indexOf } from '../../utility/array';
import { Color, getBackgroundColorClass, getColorClass } from '../../utility/color';
import { encodePercent } from '../../utility/string';
import { estimateStringWidth } from '../../utility/string-width';

import { ClickToCopy } from '../../react/copy';
import { BasicState, DetermineButton, DynamicTextEntry } from '../../react/entry';
import { Tool } from '../../react/injection';
import { getInput } from '../../react/input';
import { join } from '../../react/utility';
import { VersionedStore } from '../../react/versioned-store';

import { f, Factor, factorize, sortAndCombineFactors } from '../../math/factorization';
import { AdditionSign, DivisionSign, encodeInteger, Exponent, Integer, MinusSign, MultiplicationSign } from '../../math/formatting';
import { Group, GroupElement } from '../../math/group';
import { decodeInteger, determineIntegerFormat, IntegerFormat } from '../../math/integer';
import { MultiplicativeRing, MultiplicativeRingElement } from '../../math/multiplicative-ring';
import { isProbablePrime } from '../../math/prime';
import { abs, chineseRemainder, getRandomInteger, greatestCommonDivisor, halve, hundred, isEven, minusOne, one, sqrt, three, two, zero } from '../../math/utility';

import { createMeteredAnimation, initialIntegerMeteredAnimationOutputState, IntegerMeteredAnimationOutputState, minDelay, SetOutput } from '../utility/animation';
import { renderFactorsOrPrime } from '../utility/factors';
import { integerInputWidth, positiveInteger } from '../utility/integer';

function onUpOrDownInput(event: 'up' | 'down', input: string, inputs: Readonly<DiscreteLogarithmState>): string {
    const n = decodeInteger(inputs.n);
    let result = (decodeInteger(input) + (event === 'up' ? one : minusOne)) % n;
    if (result === zero) {
        result = n;
    }
    return encodeInteger(result, determineIntegerFormat(input));
}

export const generateInput: DetermineButton<string, DiscreteLogarithmState> = {
    label: 'Random',
    tooltip: 'Generates a random input to the linear one-way function.',
    requireValidDependencies: true,
    requireIndependentlyValidInput: true,
    onClick: async (input, { n }) => encodeInteger(getRandomInteger(one, decodeInteger(n)), determineIntegerFormat(input)),
}

export const k: DynamicTextEntry<DiscreteLogarithmState> = {
    ...positiveInteger,
    label: 'Input k',
    tooltip: 'How many times the generator shall be repeated.',
    defaultValue: '42',
    inputWidth: integerInputWidth - 72,
    dependencies: 'n',
    requireValidDependenciesForUpOrDown: true,
    onUpOrDown: onUpOrDownInput,
    determine: generateInput,
};

export interface DiscreteLogarithmState {
    n: string;
    k: string;
    K: string;
    d: number;
}

export const updateFrequency = BigInt(1_000_000);

export interface DiscreteLogarithmOutputState<G extends Group<G, E>, E extends GroupElement<G, E>> extends IntegerMeteredAnimationOutputState {
    G?: E;
    K?: E;
    k?: bigint | undefined;
}

export const initialDiscreteLogarithmOutputState: DiscreteLogarithmOutputState<any, any> = initialIntegerMeteredAnimationOutputState;

export function getSubgroupError(G: GroupElement<any, any>, K: GroupElement<any, any>, format: IntegerFormat, uncertainty = false): JSX.Element {
    return <Fragment>{K.render(format)} is {uncertainty && 'probably'} not in the subgroup generated by {G.render(format)}.</Fragment>;
}

function getNextPollardsRhoElement<G extends Group<G, E>, E extends GroupElement<G, E>>(G: E, K: E, S: E, a: MultiplicativeRingElement, b: MultiplicativeRingElement): [E, MultiplicativeRingElement, MultiplicativeRingElement] {
    switch (S.toInteger() % three) {
        case zero:
            return [S.combine(G), a.increment(), b];
        case one:
            return [S.combine(K), a, b.increment()];
        case two:
            return [S.combine(S), a.double(), b.double()];
        default:
            throw new Error('This cannot happen.');
    }
}

export function renderDiscreteLogarithmProblem<G extends Group<G, E>, E extends GroupElement<G, E>>(state: Readonly<DiscreteLogarithmOutputState<G, E>>): JSX.Element {
    const group = state.G!.group;
    return <table className="align">
        <tr>
            <td><b>Problem</b>: Find k so that {group.renderRepetition('G', 'k')}</td>
            <td>{group.renderAbstractEquality('m')} K</td>
        </tr>
        <tr>
            <td>{state.G!.renderRepetition('k')}</td>
            <td>{group.renderConcreteEquality(state.format)} {state.K!.render(state.format)}</td>
        </tr>
    </table>;
}

export class DiscreteLogarithms<State extends DiscreteLogarithmState & BasicState<State>, G extends Group<G, E>, E extends GroupElement<G, E>> {
    public readonly binaryRepetition: Tool
    public readonly exhaustiveSearch: Tool
    public readonly babyStepGiantStep: Tool
    public readonly pollardsRhoAlgorithm: Tool
    public readonly pohligHellmanAlgorithm: Tool

    public constructor(
        store: VersionedStore<State>,
        getGenerator: (state: State) => E,
        toolPrefix: string,
        encodeGenerator: (G: E, n: bigint, format: IntegerFormat) => string,
    ) {
        const Input = getInput(store);

        /* ------------------------------ Binary repetition ------------------------------ */

        {
            const verb1 = toolPrefix === 'elliptic-curve' ? 'double' : 'square';
            const verb2 = toolPrefix === 'elliptic-curve' ? 'add' : 'multiply';

            function RawOutput(state: Readonly<State>): JSX.Element {
                const format = determineIntegerFormat(state.n);
                const G = getGenerator(state);
                const group = G.group;
                const k = decodeInteger(state.k);
                const kBin = k.toString(2);
                const kBinArray = Array.from(kBin);
                const abstractEquality = group.renderAbstractEquality('m');
                const rows = new Array<ReactNode>();

                let K = G;
                let e = one;

                for (let i = 0; i <= kBinArray.length - 1; i++) {
                    if (i > 0) {
                        K = K.combine(K);
                        e *= two;
                        if (kBinArray[i] === '1') {
                            K = K.combine(G);
                            e++;
                        }
                    }
                    const background = i === kBinArray.length - 1 ? getBackgroundColorClass('green', ' ') : '';
                    rows.push(<tr>
                        <td>{kBinArray[i]}</td>
                        <td className={'text-right pr-space' + background}>
                            {group.renderRepetition('G', e, false, format)}
                        </td>
                        <td className={'pl-space pr-space' + background}>
                            {abstractEquality}
                        </td>
                        <td className={'pl-space' + background}>
                            {i === kBinArray.length - 1 ? <ClickToCopy>{K.render(format)}</ClickToCopy> : K.render(format)}
                        </td>
                        <td>{i > 0 ? verb1 + (kBinArray[i] === '1' ? ' and ' + verb2 : '') : ''}</td>
                    </tr>);
                }

                return <Fragment>
                    <p className="text-center">k = {kBin}<sub>2</sub> ({kBinArray.length} bits)</p>
                    <table className="table-with-vertical-border-after-column-1 text-break">
                        <thead>
                            <tr className="text-nowrap">
                                <th>k<sub>i</sub></th>
                                <th className="text-right pr-space">{group.renderRepetition('G', 'k')}</th>
                                <th className="pl-space pr-space">{abstractEquality}</th>
                                <th className="pl-space">K</th>
                                <th>Action</th>
                            </tr>
                        </thead>
                        <tbody>
                            {rows}
                        </tbody>
                    </table>
                </Fragment>;
            }

            const Output = store.injectCurrentState<{}>(RawOutput);

            this.binaryRepetition = [
                <Fragment>
                    <Input entries={{
                        ...store.entries,
                        K: undefined,
                        d: undefined,
                    }} inColumns/>
                    <Output/>
                </Fragment>,
                store,
            ];
        }

        /* ------------------------------ Exhaustive search ------------------------------ */

        {
            interface OutputState extends DiscreteLogarithmOutputState<G, E> {
                c: bigint;
                C?: E;
                minWidth: number;
            }

            function render(state: Readonly<OutputState>): ReactElement {
                const group = state.G!.group;
                return <Fragment>
                    {renderDiscreteLogarithmProblem(state)}
                    <p className="text-center">
                        {group.renderRepetition('G', 'c')} {group.renderAbstractEquality('m')} {' '}
                        {state.G!.renderRepetition(state.c, state.format, false, state.finished ? 'green' : 'orange')} {' '}
                        {group.renderConcreteEquality(state.format)} <span className="d-inline-block text-left" style={{ minWidth: state.minWidth }}>{state.C!.render(state.format, state.finished ? 'blue' : 'red')}</span>
                    </p>
                    {state.k !== undefined && <p className="text-center">
                        k = <ClickToCopy><Integer integer={state.k!} format={state.format} color="green"/></ClickToCopy>
                    </p>}
                </Fragment>;
            }

            async function run(state: Readonly<State>, setOutput: SetOutput<OutputState>): Promise<void> {
                const G = getGenerator(state);
                const K = G.group.getElementFromString(state.K);
                const format = determineIntegerFormat(state.n);
                let c = one;
                let C = G;
                await setOutput(minDelay, { steps: c - one, c, C, G, K, format, minWidth: G.group.estimateMaxElementWidth(format) });
                const n = decodeInteger(state.n);
                const delay = state.d * 1000;
                while (true) {
                    if (C.equals(K)) {
                        await setOutput(0, { steps: c - one, k: c, c, C });
                        return;
                    }
                    if (c === n) {
                        await setOutput(0, { steps: c - one, c, C, error: getSubgroupError(G, K, format) });
                        return;
                    }
                    if (delay > 0 || (c - one) % updateFrequency === zero) {
                        await setOutput(delay || minDelay, { steps: c - one, c, C });
                    }
                    c++;
                    C = C.combine(G);
                }
            }

            const [search, Output] = createMeteredAnimation(
                {
                    ...initialDiscreteLogarithmOutputState,
                    c: zero,
                    minWidth: 0,
                },
                state => state.c !== zero,
                render,
                run,
            );

            this.exhaustiveSearch = [
                <Fragment>
                    <Input entries={{
                        ...store.entries,
                        k: undefined,
                    }} submit={{
                        label: 'Search',
                        tooltip: 'Search for the input k which produces the given output K.',
                        onClick: search,
                    }} inColumns/>
                    <Output/>
                </Fragment>,
                store,
                search,
            ];
        }

        /* ------------------------------ Baby-step giant-step algorithm ------------------------------ */

        {
            interface OutputState extends DiscreteLogarithmOutputState<G, E> {
                elements?: (E | undefined)[];
                C?: E;
                c?: bigint;
                found: number;
                minWidth: number;
                columnWidth: number;
            }

            const elementColor: Color = 'blue';
            const exponentColor: Color = 'purple';
            const indexColor: Color = 'pink';

            function render(state: Readonly<OutputState>): ReactElement {
                const group = state.G!.group;
                return <Fragment>
                    {renderDiscreteLogarithmProblem(state)}
                    {state.elements && <p className="text-right" style={{ columnWidth: state.columnWidth }}>
                        {state.elements.map((element, index) => element === undefined ? <div key={index}>…</div> : <div key={index}>
                            {group.renderRepetition('G', index + 1, false, 'decimal', index === state.found ? indexColor : undefined)} {group.renderAbstractEquality('m')} <span className="d-inline-block" style={{ minWidth: state.minWidth }}>{element.render(state.format, index === state.found ? elementColor : undefined)}</span>
                        </div>)}
                    </p>}
                    {state.C && <p className="text-center">
                        K {group.inverseCombinationSymbol} {group.renderRepetition('G', 'c')} {group.renderAbstractEquality('m')} {' '}
                        {state.K!.render(state.format)} {group.inverseCombinationSymbol} {state.G!.renderRepetition(state.c!, state.format, false, state.found >= 0 ? exponentColor : 'orange')} {' '}
                        {group.renderConcreteEquality(state.format)} <span className="d-inline-block text-left" style={{ minWidth: state.minWidth }}>{state.C!.render(state.format, state.found >= 0 ? elementColor : 'red')}</span>
                    </p>}
                    {state.k !== undefined && <p className="text-center">
                        k = c + i = <Integer integer={state.c!} format={state.format} color={exponentColor}/> + <Integer integer={state.found + 1} format={state.format} color={indexColor}/> = <ClickToCopy><Integer integer={state.k!} format={state.format} color="green"/></ClickToCopy>
                    </p>}
                </Fragment>;
            }

            async function run(state: Readonly<State>, setOutput: SetOutput<OutputState>): Promise<void> {
                const delay = state.d * 1000;
                const G = getGenerator(state);
                const K = G.group.getElementFromString(state.K);
                const format = determineIntegerFormat(state.n);
                const n = decodeInteger(state.n);
                const rounding = n > hundred ? 10 : 1;
                const size = Math.min(100, Math.round(Math.sqrt(Number(n)) / rounding) * rounding);
                const minWidth = G.group.estimateMaxElementWidth(format);
                const columnWidth = estimateStringWidth(encodeInteger(size) + 'G =n ') + minWidth;
                await setOutput(0, { G, K, format, minWidth, columnWidth });
                const elements = new Array<E | undefined>(size).fill(undefined);
                const elementLookup: { [key: string]: number } = {};
                let steps = zero;
                let element = G.group.identity;
                for (let i = 0; i < size; i++) {
                    steps++;
                    element = element.combine(G);
                    elements[i] = element;
                    elementLookup[element.toString()] = i;
                    if (delay > 0) {
                        await setOutput(delay, { steps, elements });
                    }
                }
                if (delay === 0) {
                    await setOutput(minDelay, { steps, elements });
                }
                const stepSize = BigInt(size);
                const stepElement = element.invert();
                let C = K;
                let c = zero;
                let counter = zero;
                while (true) {
                    const index = elementLookup[C.toString()];
                    if (index !== undefined) {
                        await setOutput(0, { steps, C, c, k: BigInt(index + 1) + c, found: index });
                        return;
                    }
                    if (c > n) {
                        await setOutput(0, { steps, C, c, error: getSubgroupError(G, K, format) });
                        return;
                    }
                    if (delay > 0 || counter % updateFrequency === zero) {
                        await setOutput(delay || minDelay, { steps, C, c });
                    }
                    C = C.combine(stepElement);
                    c += stepSize;
                    steps++;
                    counter++;
                }
            }

            const [search, Output] = createMeteredAnimation(
                {
                    ...initialDiscreteLogarithmOutputState,
                    found: -1,
                    minWidth: 0,
                    columnWidth: 0,
                },
                state => state.elements !== undefined,
                render,
                run,
            );

            this.babyStepGiantStep = [
                <Fragment>
                    <Input entries={{
                        ...store.entries,
                        k: undefined,
                    }} submit={{
                        label: 'Search',
                        tooltip: 'Search for the input k which produces the given output K.',
                        onClick: search,
                    }} inColumns/>
                    <Output/>
                </Fragment>,
                store,
                search,
            ];
        }

        /* ------------------------------ Pollard's rho algorithm ------------------------------ */

        // C = G^a * K^b

        {
            interface OutputState extends DiscreteLogarithmOutputState<G, E> {
                elements?: E[] | undefined;
                loopIndex: number;
                i: [number, number];
                n: bigint;
                factors?: Factor[] | null;
                sqrtOfN: bigint;
                C?: [E, E];
                a?: [MultiplicativeRingElement, MultiplicativeRingElement];
                b?: [MultiplicativeRingElement, MultiplicativeRingElement];
                solutions?: [MultiplicativeRingElement, E][];
                match: boolean;
                elementWidth: number;
                columnWidth: number;
                minWidth: number;
            }

            const colors: [Color, Color] = ['orange', 'red'];
            function getRowColorClass(i: [number, number], index: number): string | undefined {
                if (i[0] === index) {
                    if (i[1] === index) {
                        return getColorClass('green');
                    } else {
                        return getColorClass(colors[0]);
                    }
                } else if (i[1] === index) {
                    return getColorClass(colors[1]);
                } else {
                    return undefined;
                }
            }

            const aColors: Color[] = ['yellow', 'brown'];
            const bColors: Color[] = ['purple', 'pink'];

            function render(state: Readonly<OutputState>): ReactElement {
                const group = state.G!.group;
                return <Fragment>
                    {renderDiscreteLogarithmProblem(state)}
                    <table className="align">
                        {state.factors && <tr><td>G's order n: <Integer integer={state.n} format={state.format}/></td><td>{renderFactorsOrPrime(state.factors!, state.format)}</td></tr>}
                        <tr><td><abbr title="SQuare RooT">sqrt</abbr>(<Integer integer={state.n} format={state.format}/>)</td><td>≈ <Integer integer={state.sqrtOfN} format={state.format}/></td></tr>
                    </table>
                    {state.elements && <table className="align">
                        {state.elements.map((element, index) => <tr className={getRowColorClass(state.i, index)}>
                            <td className="text-left color-text" style={{ minWidth: 50 }}>
                                {index === state.loopIndex && 'Loop:'}
                            </td>
                            <td className="text-right" style={{ minWidth: state.elementWidth }}>
                                {element.render(state.format)}
                            </td>
                            <td className="text-left" style={{ minWidth: state.columnWidth }}>
                                {state.i[0] === index && <Fragment>
                                    {group.renderConcreteEquality(state.format)} {state.G!.renderRepetition(state.a![0].toInteger(), state.format)} {group.combinationSymbol} {state.K!.renderRepetition(state.b![0].toInteger(), state.format)} {' '}
                                </Fragment>}
                                {state.i[1] === index && <Fragment>
                                    {group.renderConcreteEquality(state.format)} {state.G!.renderRepetition(state.a![1].toInteger(), state.format)} {group.combinationSymbol} {state.K!.renderRepetition(state.b![1].toInteger(), state.format)} {' '}
                                </Fragment>}
                            </td>
                        </tr>)}
                    </table>}
                    <table className="align">
                        {colors.map((color, index) => <tr>
                            <td className="text-nowrap">
                                C<sub>{index + 1}</sub> {group.renderAbstractEquality('m')} {group.renderRepetition('G', <Fragment>a<sub>{index + 1}</sub></Fragment>)} {group.combinationSymbol} {group.renderRepetition('K', <Fragment>b<sub>{index + 1}</sub></Fragment>)}
                            </td>
                            <td style={{ minWidth: state.minWidth }}>
                                {group.renderAbstractEquality('m')} {state.G!.renderRepetition(state.a![index].toInteger(), state.format, false, aColors[index])} {group.combinationSymbol} {state.K!.renderRepetition(state.b![index].toInteger(), state.format, false, bColors[index])} {' '}
                                {group.renderConcreteEquality(state.format)} {state.C![index].render(state.format, state.match ? 'green' : color)}
                            </td>
                        </tr>)}
                    </table>
                    {state.solutions !== undefined && <Fragment>
                        <table className="align">
                            <tr>
                                <td>(b<sub>1</sub><MinusSign/>b<sub>2</sub>)<MultiplicationSign/>k</td>
                                <td>=<sub>n</sub> a<sub>2</sub><MinusSign/>a<sub>1</sub></td>
                            </tr>
                            <tr>
                                <td>(<Integer integer={state.b![0]} format={state.format} color={bColors[0]}/><MinusSign/><Integer integer={state.b![1]} format={state.format} color={bColors[1]}/>)<MultiplicationSign/>k</td>
                                <td>=<sub><Integer integer={state.n} format={state.format}/></sub> <Integer integer={state.a![1]} format={state.format} color={aColors[1]}/><MinusSign/><Integer integer={state.a![0]} format={state.format} color={aColors[0]}/></td>
                            </tr>
                            <tr>
                                <td><Integer integer={state.b![0].subtract(state.b![1])} format={state.format}/><MultiplicationSign/>k</td>
                                <td>=<sub><Integer integer={state.n} format={state.format}/></sub> <Integer integer={state.a![1].subtract(state.a![0])} format={state.format}/></td>
                            </tr>
                        </table>
                        {state.solutions.length > 0 && <Fragment>
                            <p className="text-center">k ∈ {'{'}{join(state.solutions.map(solution => <Integer integer={solution[0]} format={state.format}/>))}{'}'}</p>
                            <table className="align">
                                {state.solutions.map(solution => <tr>
                                    <td>{state.G!.renderRepetition(solution[0].toInteger(), state.format, false, solution[1].equals(state.K as E) ? 'green' : 'red')}</td>
                                    <td>{group.renderConcreteEquality(state.format)} {solution[1].render(state.format, solution[1].equals(state.K as E) ? 'green' : 'red')}</td>
                                </tr>)}
                            </table>
                        </Fragment>}
                    </Fragment>}
                    {state.k !== undefined && <p className="text-center">
                        k = <ClickToCopy><Integer integer={state.k!} format={state.format} color="green"/></ClickToCopy>
                    </p>}
                </Fragment>;
            }

            async function run(state: Readonly<State>, setOutput: SetOutput<OutputState>): Promise<void> {
                const delay = state.d * 1000;
                const G = getGenerator(state);
                const K = G.group.getElementFromString(state.K);
                const n = decodeInteger(state.n);
                const factors = factorize(n);
                const sqrtOfN = sqrt(n);
                const loop = delay > 0 && n <= BigInt(400);
                const elements = loop ? [G.group.identity] : undefined;
                let loopIndex = -1;
                const i: [number, number] = [0, 0];
                const ring = new MultiplicativeRing(n);
                const C: [E, E] = [G.group.identity, G.group.identity];
                const a: [MultiplicativeRingElement, MultiplicativeRingElement] = [ring.zero, ring.zero];
                const b: [MultiplicativeRingElement, MultiplicativeRingElement] = [ring.zero, ring.zero];
                const format = determineIntegerFormat(state.n);
                const elementWidth = G.group.estimateMaxElementWidth(format);
                const columnWidth = estimateStringWidth(' = ') * 4 + estimateStringWidth(encodeInteger(n)) * 4.5 + elementWidth * 4;
                const minWidth = 4 + estimateStringWidth(' = ') * 3 + estimateStringWidth(encodeInteger(n)) * 2.25 + elementWidth * 3;
                await setOutput(delay || minDelay, { elements, n, factors, sqrtOfN, G, K, C, a, b, format, elementWidth, columnWidth, minWidth });

                function incrementIndexes(...indexes: number[]) {
                    if (loop) {
                        if (loopIndex === -1) {
                            loopIndex = indexOf(elements!, C[1]);
                            if (loopIndex === -1) {
                                elements!.push(C[1]);
                            }
                        }
                        for (const index of indexes) {
                            i[index]++;
                            if (loopIndex >= 0 && i[index] === elements!.length) {
                                i[index] = loopIndex;
                            }
                        }
                    }
                }

                let steps = zero;
                while (true) {
                    steps++;
                    [C[0], a[0], b[0]] = getNextPollardsRhoElement(G, K, C[0], a[0], b[0]);
                    [C[1], a[1], b[1]] = getNextPollardsRhoElement(G, K, C[1], a[1], b[1]);
                    incrementIndexes(0, 1);
                    [C[1], a[1], b[1]] = getNextPollardsRhoElement(G, K, C[1], a[1], b[1]);
                    incrementIndexes(1);
                    if (C[0].equals(C[1])) {
                        let solutions: [MultiplicativeRingElement, E][];
                        let error: ReactNode;
                        const difference = b[0].subtract(b[1]);
                        const gcd = greatestCommonDivisor(n, difference.toInteger());
                        let k: bigint | undefined;
                        if (difference.isZero()) {
                            solutions = [];
                            error = <Fragment>Since b<sub>1</sub> =<sub>n</sub> b<sub>2</sub>, every input k is still possible.</Fragment>;
                        } else if (gcd > hundred) {
                            solutions = [];
                            error = <Fragment>There are <Integer integer={gcd} format={format}/> solutions for k, which are too many to display.</Fragment>;
                        } else {
                            solutions = difference.getFactorsTo(a[1].subtract(a[0])).map(k => [k, G.repeat(k)]);
                            k = solutions.find(solution => solution[1].equals(K))?.[0].toInteger();
                            if (k === undefined) {
                                error = getSubgroupError(G, K, format);
                            }
                        }
                        await setOutput(0, { steps, elements, loopIndex, i, C, a, b, solutions, k, match: true, error });
                        return;
                    }
                    if (delay > 0 || steps % updateFrequency === zero) {
                        await setOutput(delay || minDelay, { steps, elements, loopIndex, i, C, a, b, match: false });
                    }
                }
            }

            const [search, Output] = createMeteredAnimation(
                {
                    ...initialDiscreteLogarithmOutputState,
                    loopIndex: -1,
                    i: [0, 0],
                    n: zero,
                    sqrtOfN: zero,
                    match: true,
                    elementWidth: 0,
                    columnWidth: 0,
                    minWidth: 0,
                },
                state => state.G !== undefined,
                render,
                run,
            );

            this.pollardsRhoAlgorithm = [
                <Fragment>
                    <Input entries={{
                        ...store.entries,
                        k: undefined,
                    }} submit={{
                        label: 'Search',
                        tooltip: 'Search for the input k which produces the given output K.',
                        onClick: search,
                    }} inColumns/>
                    <Output/>
                </Fragment>,
                store,
                search,
            ];
        }

        /* ------------------------------ Pohlig-Hellman algorithm ------------------------------ */

        {
            interface Solution {
                s: bigint;
                D: E;
                d?: bigint;
                steps: bigint;
            }

            interface Problem {
                p: bigint;
                e: bigint;
                Gi: E;
                Ki: E;
                H: E; // Gi^(p^(e-1))
                sqrtOfP: bigint;
                solutions: Solution[];
                k?: bigint;
            }

            interface OutputState extends DiscreteLogarithmOutputState<G, E> {
                n: bigint;
                factors: Factor[];
                problems?: Problem[];
            }

            const exhaustiveSearchBoundary = hundred;

            function render(state: Readonly<OutputState>): ReactElement {
                const group = state.G!.group;
                const abstractEquality = group.renderAbstractEquality('m');
                const concreteEquality = group.renderConcreteEquality(state.format);
                return <Fragment>
                    {renderDiscreteLogarithmProblem(state)}
                    <p className="text-center">
                        G's order n: <Integer integer={state.n} format={state.format}/> {renderFactorsOrPrime(state.factors!, state.format)}{!state.problems && <Fragment><MultiplicationSign/>…</Fragment>}{' '}
                        <a href={`#tool-integer-factorization-pollards-rho&integer=${encodePercent(encodeInteger(state.n, state.format))}&totients=false&delay=0`} title="Factorize the order with Pollard's rho factorization algorithm.">↗</a>
                    </p>
                    {state.problems && state.problems.map((problem, index) => <Fragment>
                        <hr/>
                        <div className="text-center"><b>{index + 1}. Subproblem</b>: Find k<sub>{index + 1}</sub> so that {group.renderRepetition(<Fragment>G<sub>{index + 1}</sub></Fragment>, <Fragment>k<sub>{index + 1}</sub></Fragment>)} {abstractEquality} K<sub>{index + 1}</sub>, where</div>
                        <table className="align">
                            <tr><td>p<sub>{index + 1}</sub></td><td>= <Integer integer={problem.p} format={state.format} color="pink"/></td></tr>
                            <tr><td>e<sub>{index + 1}</sub></td><td>= <Integer integer={problem.e} format={state.format}/></td></tr>
                            <tr><td>K<sub>{index + 1}</sub></td><td>{abstractEquality} {group.renderRepetition('K', <Fragment>n<DivisionSign/>p<sub>{index + 1}</sub><Exponent exponent={<Fragment>e<sub>{index + 1}</sub></Fragment>}/></Fragment>, true)} {concreteEquality} {problem.Ki.render(state.format)}</td></tr>
                            <tr><td>G<sub>{index + 1}</sub></td><td>{abstractEquality} {group.renderRepetition('G', <Fragment>n<DivisionSign/>p<sub>{index + 1}</sub><Exponent exponent={<Fragment>e<sub>{index + 1}</sub></Fragment>}/></Fragment>, true)} {concreteEquality} {problem.Gi.render(state.format)}</td></tr>
                            <tr><td>H<sub>{index + 1}</sub></td><td>{abstractEquality} {group.renderRepetition(<Fragment>G<sub>{index + 1}</sub></Fragment>, <Fragment>p<sub>{index + 1}</sub><Exponent exponent={<Fragment>e<sub>{index + 1}</sub><MinusSign/>1</Fragment>}/></Fragment>, true)} {concreteEquality} {problem.H.render(state.format)}</td></tr>
                            {problem.p > exhaustiveSearchBoundary && <tr><td><abbr title="SQuare RooT">sqrt</abbr>(p<sub>{index + 1}</sub>)</td><td>= <Integer integer={problem.sqrtOfP} format={state.format}/></td></tr>}
                        </table>
                        <table className="text-right text-nowrap">
                            <thead>
                                <tr>
                                    <th>j</th>
                                    <th>s<sub>j</sub> = s<sub>j<MinusSign/>1</sub><AdditionSign/>d<sub>j<MinusSign/>1</sub><MultiplicationSign/>p<sub>{index + 1}</sub><Exponent exponent={<Fragment>j<MinusSign/>1</Fragment>}/></th>
                                    <th>D<sub>j</sub> {abstractEquality} {group.renderRepetition(<Fragment>(K<sub>{index + 1}</sub>{group.inverseCombinationSymbol}{group.renderRepetition(<Fragment>G<sub>{index + 1}</sub></Fragment>, <Fragment>s<sub>j</sub></Fragment>)})</Fragment>, <Fragment>p<sub>{index + 1}</sub><Exponent exponent={<Fragment>e<sub>{index + 1}</sub><MinusSign/>1<MinusSign/>j</Fragment>}/></Fragment>)}</th>
                                    <th>d<sub>j</sub> so that {group.renderRepetition(<Fragment>H<sub>{index + 1}</sub></Fragment>, <Fragment>d<sub>j</sub></Fragment>)} {abstractEquality} D<sub>j</sub></th>
                                    <th>Steps</th>
                                    <th></th>
                                </tr>
                            </thead>
                            <tbody>
                                {problem.solutions.map((solution, j) => <tr>
                                    <td><Integer integer={j} color="purple"/></td>
                                    <td><Integer integer={solution.s} format={state.format}/></td>
                                    <td>{solution.D.render(state.format)}</td>
                                    <td>{solution.d !== undefined ? <Integer integer={solution.d} format={state.format} color="blue"/> : '…'}</td>
                                    <td><Integer integer={solution.steps} format={state.format}/></td>
                                    <td>{problem.p > exhaustiveSearchBoundary ?
                                        <a href={`#tool-discrete-logarithm-${toolPrefix}-pollards-rho-algorithm${encodeGenerator(problem.H, problem.p, state.format)}&K=${encodePercent(solution.D.to(state.format))}`} title="Use Pollard's rho algorithm to find the discrete logarithm.">↗</a> :
                                        !solution.D.isIdentity() && <a href={`#tool-discrete-logarithm-${toolPrefix}-exhaustive-search${encodeGenerator(problem.H, problem.p, state.format)}&K=${encodePercent(solution.D.to(state.format))}`} title="Use exhaustive search to find the discrete logarithm.">↗</a>
                                    }</td>
                                </tr>)}
                            </tbody>
                        </table>
                        {problem.k !== undefined && <p className="text-center">
                            k<sub>{index + 1}</sub> = {join(problem.solutions.map((solution, i) => <Fragment>
                                <Integer integer={solution.d!} format={state.format} color="blue"/><MultiplicationSign/><Integer integer={problem.p} format={state.format} color="pink"/><Exponent exponent={<Integer integer={i} color="purple"/>}/>
                            </Fragment>), <AdditionSign/>)} = <Integer integer={problem.k} format={state.format} color="green"/>
                        </p>}
                    </Fragment>)}
                    <hr/>
                    {state.k !== undefined && <table className="align">
                        {state.problems!.map((problem, index) => <tr>
                            <th>{index === 0 && 'Problem:'}</th>
                            <td>k</td>
                            <td>
                                =<sub>p<sub>{index + 1}</sub><Exponent exponent={<Fragment>e<sub>{index + 1}</sub></Fragment>}/></sub> k<sub>{index + 1}</sub>{' '}
                                =<sub><Integer integer={problem.p ** problem.e} format={state.format}/></sub> <Integer integer={problem.k!} format={state.format}/>
                            </td>
                        </tr>)}
                        <tr className="padding-top click-to-copy-padding-bottom">
                            <th>Solution:</th>
                            <td>k</td>
                            <td>
                                =<sub><Integer integer={state.n} format={state.format}/></sub> <ClickToCopy><Integer integer={state.k} format={state.format} color="green"/></ClickToCopy>{' '}
                                <a href={`#tool-discrete-logarithm-${toolPrefix}-montgomerys-ladder${encodeGenerator(state.G!, state.n, state.format)}&k=${encodePercent(encodeInteger(state.k, state.format))}&K=${encodePercent(state.K!.to(state.format))}`} title="Use Montgomery's ladder to verify this solution.">↗</a>
                            </td>
                        </tr>
                    </table>}
                </Fragment>;
            }

            async function run(state: Readonly<State>, setOutput: SetOutput<OutputState>): Promise<void> {
                const G = getGenerator(state);
                const K = G.group.getElementFromString(state.K);
                const n = decodeInteger(state.n);
                const format = determineIntegerFormat(state.n);
                await setOutput(minDelay, { G, K, n, format });
                let steps = zero;

                // Factorize n
                const factors: bigint[] = [];
                let t = n;
                while (isEven(t)) {
                    t = halve(t);
                    factors.push(two);
                }
                if (t !== n) {
                    await setOutput(minDelay, { steps, factors: sortAndCombineFactors(factors) });
                }
                if (t !== one) {
                    const queue = [t];
                    outer: while (queue.length > 0) {
                        const n = queue.pop()!;
                        if (isProbablePrime(n, 64)) {
                            factors.push(n);
                            await setOutput(minDelay, { steps, factors: sortAndCombineFactors(factors) });
                        } else {
                            for (let addend = one; addend < n; addend++) {
                                let a = two;
                                let b = two;
                                let gcd = one;
                                while (gcd === one) {
                                    steps++;
                                    a = f(a, n, addend);
                                    b = f(f(b, n, addend), n, addend);
                                    gcd = greatestCommonDivisor(n, abs(a - b));
                                    if (steps % updateFrequency === zero) {
                                        await setOutput(minDelay, { steps });
                                    }
                                }
                                if (gcd !== n) {
                                    queue.push(n / gcd, gcd);
                                    continue outer;
                                }
                            }
                            await setOutput(0, { steps, error: `Failed to factor ${encodeInteger(n)}.` });
                            return;
                        }
                    }
                }
                const sortedFactors = sortAndCombineFactors(factors);

                // Solve the various discrete logarithms
                const problems: Problem[] = [];
                for (const factor of sortedFactors) {
                    const p = factor.base;
                    const e = factor.exponent;
                    const ni = n / (p ** e);
                    const Gi = G.repeat(ni);
                    const Ki = K.repeat(ni);
                    const H = Gi.repeat(p ** (e - one));
                    const sqrtOfP = sqrt(p);
                    const solutions: Solution[] = [];
                    const problem: Problem = { p, e, Gi, Ki, H, sqrtOfP, solutions };
                    problems.push(problem);
                    await setOutput(minDelay, { problems });
                    const ring = MultiplicativeRing.fromPrime(p);
                    const max = Number(e);
                    for (let j = 0; j < max; j++) {
                        const J = BigInt(j);
                        const s = j === 0 ? zero : solutions[j - 1].s + solutions[j - 1].d! * p ** (J - one);
                        const D = Ki.combine(Gi.repeat(-s)).repeat(p ** (e - one - J));
                        const solution: Solution = { s, D, steps: zero };
                        solutions.push(solution);
                        if (D.isIdentity()) {
                            solution.d = zero;
                        } else if (p < exhaustiveSearchBoundary) {
                            let c = one;
                            let C = H;
                            while (!C.equals(D)) {
                                c++;
                                if (c === p) {
                                    solution.steps = c - one;
                                    steps += solution.steps;
                                    await setOutput(0, { steps, problems, error: getSubgroupError(G, K, format) });
                                    return;
                                }
                                C = C.combine(H);
                            }
                            solution.d = c;
                            solution.steps = c - one;
                            steps += solution.steps;
                        } else {
                            const C: [E, E] = [G.group.identity, G.group.identity];
                            const a: [MultiplicativeRingElement, MultiplicativeRingElement] = [ring.zero, ring.zero];
                            const b: [MultiplicativeRingElement, MultiplicativeRingElement] = [ring.zero, ring.zero];
                            let randomStart = 0;
                            while (true) {
                                steps++;
                                solution.steps++;
                                [C[0], a[0], b[0]] = getNextPollardsRhoElement(H, D, C[0], a[0], b[0]);
                                [C[1], a[1], b[1]] = getNextPollardsRhoElement(H, D, C[1], a[1], b[1]);
                                [C[1], a[1], b[1]] = getNextPollardsRhoElement(H, D, C[1], a[1], b[1]);
                                if (C[0].equals(C[1])) {
                                    const difference = b[0].subtract(b[1]);
                                    if (difference.isZero()) {
                                        if (randomStart > 2) {
                                            await setOutput(0, { steps, problems, error: "Could not solve the current discrete logarithm with Pollard's rho algorithm." });
                                            return;
                                        } else {
                                            const _a = ring.getRandomElement();
                                            const _b = ring.getRandomElement();
                                            const _C = H.repeat(_a).combine(D.repeat(_b));
                                            [C[0], a[0], b[0]] = [_C, _a, _b];
                                            [C[1], a[1], b[1]] = [_C, _a, _b];
                                            randomStart++;
                                        }
                                    } else {
                                        const d = difference.getFactorsTo(a[1].subtract(a[0]));
                                        if (d.length === 1 && H.repeat(d[0]).equals(D)) {
                                            solution.d = d[0].toInteger();
                                            break;
                                        } else {
                                            await setOutput(0, { steps, problems, error: getSubgroupError(G, K, format) });
                                            return;
                                        }
                                    }
                                }
                                if (solution.steps % updateFrequency === zero) {
                                    await setOutput(minDelay, { steps, problems });
                                }
                            }
                        }
                    }
                    const lastSolution = getLastElement(solutions);
                    problem.k = lastSolution.s + lastSolution.d! * p ** (e - one);
                    await setOutput(minDelay, { steps, problems });
                }

                // Solve the Chinese remainder problem
                const k = problems.map(problem => [problem.p ** problem.e, problem.k!] as [bigint, bigint]).reduce(chineseRemainder, [one, zero])[1];
                await setOutput(0, { k });
            }

            const [search, Output] = createMeteredAnimation(
                {
                    ...initialDiscreteLogarithmOutputState,
                    n: zero,
                    factors: [],
                },
                state => state.G !== undefined,
                render,
                run,
            );

            this.pohligHellmanAlgorithm = [
                <Fragment>
                    <Input entries={{
                        ...store.entries,
                        k: undefined,
                        d: undefined,
                    }} submit={{
                        label: 'Search',
                        tooltip: 'Search for the input k which produces the given output K.',
                        onClick: search,
                    }} inColumns/>
                    <Output/>
                </Fragment>,
                store,
                search,
            ];
        }

    }
}
